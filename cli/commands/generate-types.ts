import { writeFileSync } from "fs";
import { join, dirname, relative } from "path";
import type { TronbunConfig } from "../types.js";
import * as ts from "typescript";

interface HandlerInfo {
  methodName: string;
  handlerName: string;
  hasResponseHandler?: boolean;
  parameterType: string;
  returnType: string;
}

interface WindowMetadata {
  name: string;
  sourceFile: string;
  className: string;
  handlers: HandlerInfo[];
}

export class GenerateTypesCommand {
  static async generateTypes(config: TronbunConfig, projectRoot: string): Promise<void> {
    console.log("ðŸ”§ Generating IPC types...");

    const configPath = ts.findConfigFile(projectRoot, ts.sys.fileExists, 'tsconfig.json');
    
    if (!configPath) {
      console.error("âŒ Could not find tsconfig.json");
      return;
    }

    try {
      const { config: tsConfig } = ts.readConfigFile(configPath, ts.sys.readFile);
      const { options, fileNames } = ts.parseJsonConfigFileContent(
        tsConfig,
        ts.sys,
        dirname(configPath)
      );

      const program = ts.createProgram(fileNames, {
        ...options,
        experimentalDecorators: true,
        emitDecoratorMetadata: true,
      });

      const metadata = extractWindowsFromProgram(program, projectRoot);

      if (metadata.length === 0) {
        console.log("âš ï¸  No window classes with @windowName decorators found.");
        return;
      }

      const typesPath = join(projectRoot, "src", "ipc-types.ts");

      let typeDefinitions = `// Auto-generated IPC types
// Do not edit this file manually - run 'tronbun generate-types' to regenerate
`;

      // Generate specific handler interfaces for each window
      for (const window of metadata) {
        if (window.handlers.length > 0) {
          typeDefinitions += `
// Generated handlers for ${window.className}
export interface ${window.className}Handlers {
`;
          for (const handler of window.handlers) {
            typeDefinitions += `  ${handler.handlerName}: (data: ${handler.parameterType}) => Promise<${handler.returnType}>;\n`;
          }
          typeDefinitions += `}\n`;
        }
      }

      typeDefinitions += `

declare global {
  interface Window {
`;
      
      for (const window of metadata) {
        if (window.handlers.length > 0) {
          typeDefinitions += `    ${window.name}: ${window.className}Handlers;\n`;
        }
      }
      
      typeDefinitions += `  }
}
`;

      writeFileSync(typesPath, typeDefinitions);

      console.log(`âœ… Generated types for ${metadata.length} window(s)`);
      console.log(`ðŸ“ Generated file: ${typesPath}`);
      
      // Log discovered windows
      for (const window of metadata) {
        console.log(`   â€¢ ${window.name} (${window.className})`);
      }

    } catch (error) {
      console.error("âŒ Error generating types:", error);
      throw error;
    }
  }
}

function extractWindowsFromProgram(program: ts.Program, projectRoot: string): WindowMetadata[] {
  const metadata: WindowMetadata[] = [];

  const sourceFiles = program.getSourceFiles().filter(
    file => !file.fileName.includes('node_modules') && 
            !file.fileName.includes('.d.ts') &&
            file.fileName.includes(projectRoot)
  );

  console.log(`ðŸ“‚ Processing ${sourceFiles.length} source files...`);

  for (const sourceFile of sourceFiles) {
    const windowsInFile = extractWindowsFromSourceFile(sourceFile);
    metadata.push(...windowsInFile);
  }

  return metadata;
}

function extractWindowsFromSourceFile(sourceFile: ts.SourceFile): WindowMetadata[] {
  const windows: WindowMetadata[] = [];

  function visit(node: ts.Node) {
    if (ts.isClassDeclaration(node)) {
      const windowName = extractWindowNameFromClass(node);
      if (windowName) {
        const handlers = extractHandlersFromClass(node);
        windows.push({ 
          name: windowName, 
          sourceFile: sourceFile.fileName, 
          className: node.name?.text || 'Unknown',
          handlers
        });
      }
    }
    ts.forEachChild(node, visit);
  }

  visit(sourceFile);
  return windows;
}

function extractWindowNameFromClass(classNode: ts.ClassDeclaration): string | null {
  const decorators = ts.canHaveDecorators(classNode) ? ts.getDecorators(classNode) : undefined;
  if (!decorators) return null;

  const windowDecorator = decorators.find(decorator => {
    if (!ts.isCallExpression(decorator.expression)) return false;
    if (!decorator.expression.expression) return false;
    if (!ts.isIdentifier(decorator.expression.expression)) return false;
    return decorator.expression.expression.text === 'windowName';
  });

  if (!windowDecorator || !ts.isCallExpression(windowDecorator.expression)) return null;

  const windowNameArg = windowDecorator.expression.arguments[0];
  if (!windowNameArg || !ts.isStringLiteral(windowNameArg)) return null;

  return windowNameArg.text;
}

function extractHandlersFromClass(classNode: ts.ClassDeclaration): HandlerInfo[] {
  const handlers: HandlerInfo[] = [];

  classNode.members.forEach(member => {
    if (ts.isMethodDeclaration(member) && member.name && ts.isIdentifier(member.name)) {
      const decorators = ts.canHaveDecorators(member) ? ts.getDecorators(member) : undefined;
      if (!decorators) return;

      const handlerDecorator = decorators.find(decorator => {
        if (!ts.isCallExpression(decorator.expression)) return false;
        if (!decorator.expression.expression) return false;
        if (!ts.isIdentifier(decorator.expression.expression)) return false;
        return decorator.expression.expression.text === 'mainHandler';
      });

      if (handlerDecorator && ts.isCallExpression(handlerDecorator.expression)) {
        const handlerNameArg = handlerDecorator.expression.arguments[0];
        if (handlerNameArg && ts.isStringLiteral(handlerNameArg)) {
          const { parameterType, returnType } = extractMethodTypes(member);
          handlers.push({
            methodName: member.name.text,
            handlerName: handlerNameArg.text,
            hasResponseHandler: false, // TODO: detect response handlers
            parameterType,
            returnType
          });
        }
      }
    }
  });

  return handlers;
}

function extractMethodTypes(method: ts.MethodDeclaration): { parameterType: string; returnType: string } {
  let parameterType = 'void';
  let returnType = 'any';

  // Extract parameter type
  if (method.parameters && method.parameters.length > 0) {
    const firstParam = method.parameters[0];
    if (firstParam && firstParam.type) {
      parameterType = typeNodeToString(firstParam.type);
    }
  }

  // Extract return type from Promise<T>
  if (method.type) {
    const typeStr = typeNodeToString(method.type);
    // Match Promise<T> pattern
    const promiseMatch = typeStr.match(/^Promise<(.+)>$/);
    if (promiseMatch && promiseMatch[1]) {
      returnType = promiseMatch[1];
    } else {
      returnType = typeStr;
    }
  }

  return { parameterType, returnType };
}

function typeNodeToString(typeNode: ts.TypeNode): string {
  switch (typeNode.kind) {
    case ts.SyntaxKind.StringKeyword:
      return 'string';
    case ts.SyntaxKind.NumberKeyword:
      return 'number';
    case ts.SyntaxKind.BooleanKeyword:
      return 'boolean';
    case ts.SyntaxKind.VoidKeyword:
      return 'void';
    case ts.SyntaxKind.AnyKeyword:
      return 'any';
    case ts.SyntaxKind.TypeReference:
      const typeRef = typeNode as ts.TypeReferenceNode;
      if (ts.isIdentifier(typeRef.typeName)) {
        let typeName = typeRef.typeName.text;
        if (typeRef.typeArguments && typeRef.typeArguments.length > 0) {
          const args = typeRef.typeArguments.map(arg => typeNodeToString(arg)).join(', ');
          typeName += `<${args}>`;
        }
        return typeName;
      }
      break;
    case ts.SyntaxKind.TypeLiteral:
      const typeLiteral = typeNode as ts.TypeLiteralNode;
      const members = typeLiteral.members.map(member => {
        if (ts.isPropertySignature(member) && member.name && ts.isIdentifier(member.name)) {
          const propName = member.name.text;
          const propType = member.type ? typeNodeToString(member.type) : 'any';
          const optional = member.questionToken ? '?' : '';
          return `${propName}${optional}: ${propType}`;
        }
        return '';
      }).filter(Boolean);
      return `{ ${members.join('; ')} }`;
    case ts.SyntaxKind.ArrayType:
      const arrayType = typeNode as ts.ArrayTypeNode;
      return `${typeNodeToString(arrayType.elementType)}[]`;
    case ts.SyntaxKind.UnionType:
      const unionType = typeNode as ts.UnionTypeNode;
      return unionType.types.map(t => typeNodeToString(t)).join(' | ');
  }
  
  // Fallback: try to get the text representation
  return typeNode.getText() || 'any';
} 